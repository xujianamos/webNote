## 1.小程序配置

### 1.1全局配置app.json



## 2.小程序生命周期

### 2.1小程序生命周期

```js
//小程序初始化完成时触发，全局只触发一次。
onLaunch (options) {  },
//小程序启动，或从后台进入前台显示时触发。
onShow (options) {},
//小程序从前台进入后台时触发。
onHide () {},
//小程序发生脚本错误或 API 调用报错时触发。
onError (msg) {},
```



### 2.2页面生命周期

5个生命周期

```js
//页面被加载出来
  onLoad(options) {},
//页面显示出来
  onShow() {},
//页面初次渲染完成时
  onReady() {},
//当页面隐藏起来时
  onHide() {},
//页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。
  onUnload() { },
```

## 3.小程序中导入wxml文件

定义模板文件:

```html
<!--1.定义的模板文件-->
<template name="contentItem">
<button size="mini">{{btnText}}</button>
<view>{{content}}</view>
</template>
<!--2.使用模板文件-->
<template is="contentItem" data="{{btnText:'按钮',content:'内容'}}"/>
```

> 注意：

- 此时只能在定义的wxml中使用模板文件，不能在其他wxml中使用

使用`import`语法导入wxml模板

1. 新建模板文件：`template.wxml`

```html
<!--template.wxml-->
<template name="contentItem">
	<button size="mini">{{btnText}}</button>
	<view>{{content}}</view>
</template>
```

2. 在其他wxml文件中导入

```html
<!--home.wxml-->
<!--1.导入模板文件-->
<import src="/wxml/template.wxml"/>
<!--2.使用导入的模板文件-->
<template is="contentItem" data="{{btnText:'按钮',content:'内容'}}"/>
```

> 注意：

`import`不能递归导入。只有`include`才能循环导入。

```html
<!--header.wxml-->
<include src="./wxml/nav.wxml" />
```

- import主要导入template模板，不能递归导入
- include将公共的wxml中的组件抽取到一个文件中，不能导入template。可以递归导入。

## 4.wxs语法

用于可以在wxml中直接写js，但是不能写es6新特性。

1.定义方式：在wxml中直接定义

```html
<！--wxs.wxml-->
  <wxs module="info">
    <!--在里面定义的变量和函数都是私有的-->
    var name='xxx';
    <!--必须导出才能被外部使用-->
    module.exports={
    name:name
    }
  </wxs>
  <view>{{info.name}}</view>  
```

2.抽离wxs为单独的文件：

在项目根目录新建wxs文件夹：

```js
//info.wxs
 var name='xxx';
function test(){
  return 'sss'
}
 module.exports={
    name:name,
   test:test
}
```

在wxml中进行导入使用

```html
<!--wxs.wxml-->
<!--导入wxs文件:不能使用绝对路径，必须使用相对路径-->
<!--<wxs src='/wxs/info.wxs' module="info"/>-->
<wxs src='../../wxs/info.wxs' module="info"/>
<view>{{info.name}}</view>
```

应用：

事件格式化：

```js
//format.wxs
function dateFormat(time){
  return str
}
module.exports={
  dateFormat:dateFormat
}
```

使用：

```html
<!--wxs.wxml-->
<wxs src="../../wxs/format.wxs" module="format"></wxs>
<view>{{format.dateFormat(time.'yyyy:mm:dd')}}</view>
```



## 5.事件

### 5.1事件传参

> 1.传递参数

通过`data-变量名字`的形式进行事件传递参数的。

```html
<block wx:for="{{titles}}" wx:key="{{index}}">
  <view bindtap="handleItemClick" 
        data-index="{{index}}" 
        data-item="{{item}}"></view>
  
</block>
```

> 2.事件中获取参数

通过`event`获取

```js
handleItemClick(event){
  const dataset = event.currentTarget.dataset
  const title=dataset.item
  const index=dataset.index
}
```

### 5.2事件冒泡与捕获

- `bind`:一层一层传递
- `catch`:阻止事件的进一步传递

```html

```





## 6.组件化开发

### 6.1创建自定义组件

自定义组件组成：与普通页面组件相同。

在根目录新建`components`文件夹用于存放自定义组件。再的`components`下新建组件文件夹用于存放不同的组件。

![image-20200928232312911](https://gitee.com/xuxujian/webNoteImg/raw/master/allimg/image-20200928232312911.png)

注意：自定义组件中需要加`component`属性

```json
//my-cpn.json
{
  "component":true,//加了这个属性才是自定义组件
  "usingComponents":{}
}
```



自定义组件命名规范：只能使用小写字母、下划线、中划线

### 6.2使用自定义组件

#### 6.2.1页面中使用自定义组件

分两步：

> 第一步：

在页面的`json`文件中进行注册

```json
{
  "usingComponents": {
    //注册
    "my-cpn":"/components/my-cpn/my-cpn"
  }
}
```

说明：键名：为待会儿页面使用的名字。键值：为自定义组件的路径。

> 第二步：

```html
<!--home.wxml-->
<!--使用自定义组件-->
<my-cpn></my-cpn>
<!--也可以使用单标签-->
<my-cpn/>
```

### 6.2.2自定义组件中使用自定义组件

与在页面中使用方式相同，先注册再使用。

### 6.3全局注册自定义组件

全局注册的组件可以再任何页面进行使用。

在`app.json`中进行全局注册：

```json
{
  "pages": [
    "pages/detail/detail",
    "pages/login/login",
    "pages/home/home"
  ],
  //全局注册组件
  "usingComponents": {
    "my-cpn":"/components/my-cpn/my-cpn"
  }
}
```

### 6.4自定义组件样式

> 组件内的样式对外部样式的影响

- 组件内的`class`样式，只对组件wxml内的节点生效，对于引用组件的page页面不生效。
- 组件内不能使用id选择器、属性选择器、标签选择器。

> 外部样式对组件内样式的影响

- 外部使用`class`样式，只对外部wxml的class生效，对组件内是不生效的
- 外部使用了id选择器，属性选择器不会对组件内产生影响
- 外部使用了标签选择器，会对组件内产生影响

结论：

- 组件内的class样式和组件外的class样式，默认是有一个隔离效果的
- 为了防止样式的错乱，官方不推荐使用id、属性、标签选择器

> 如何让class可以相互影响

![image-20200929000000925](https://gitee.com/xuxujian/webNoteImg/raw/master/allimg/image-20200929000000925.png)

### 6.5组件通信

![image-20200929000215821](https://gitee.com/xuxujian/webNoteImg/raw/master/allimg/image-20200929000215821.png)

#### 6.5.1传递数据

在组件中定义接收的属性：

```js
//my-prop.js自定义组件中
Component({
  properties:{
    title:String
  }
})

```

在自定义组件中使用数据:

```html
<!--my-prop.wxml-->
<view>{{title}}</view>
```

在页面中传递数据:

```html
<!--home.wxml-->
<my-prop title="传递数据"></my-prop>
```

> 传递数据的写法：

```js
//my-prop.js自定义组件中
Component({
  properties:{
    //写法1：
    title:String,
    //写法2：
    title:{
      type:String,
      value:'我是默认值',
      observer:function(newval,oldval){
        //newval监听传递的新值
        //oldval监听传递的旧值
      }
    }
  }
})
```

#### 6.5.2传递样式

在自定义组件的js文件中写接收的样式名：

```js
//my-prop.js自定义组件中
Component({
  properties:{
    //写法1：
    title:String,
    //写法2：
    title:{
      type:String,
      value:'我是默认值',
      observer:function(newval,oldval){
        //newval监听传递的新值
        //oldval监听传递的旧值
      }
    }
  },
  //样式
  externalClasses:['传递的样式类名','titleclass']
})
```

在自定义组件中使用数据:

```html
<!--my-prop.wxml-->
<view class="titleclass">{{title}}</view>
```

给组件传递类名：

```html
<!--home.wxml-->
<my-prop title="传递数据" titleclass="red"></my-prop>
```

此时样式还没生效，因为还没在页面上编写样式：

```css
/*home.wxss*/
.red{
  color:red;
  font-size:14rpx;
}
```

#### 6.5.3传递事件

组件中的方法需要写在`methods`中：

```js
//my-event.js
Component({
  methods:{
    //事件
    handleIncrment(){
      //向外部传递事件
      this.triggerEvent('increment',{},{})
    }
  }
})
```

在使用组件的地方进行监听发出的事件：

```html
<!--home.wxml-->
<my-event bind:increment="handleincrement"></my-event>
```

在页面实现这个方法：

```js
//home.js
Page({
  handleincrement(){
    
  }
})
```

### 6.6组件案例







### 6.7获取组件对象

在使用组件的页面中获取组件对象。

页面中使用的组件：

```html
<!--home.html-->
<my-sel class="sel-class" id="sel-id" />
```

页面中定义方法获取组件对象：

```js
//home.js
Page({
  handleIncrementCpn(){
    //const my_sel=this.selectComponent('传入组件的class或者id')
    //通过clsaa拿对象
    const my_sel=this.selectComponent('.sel-class')
    //通过id拿组件对象
    const my_sel=this.selectComponent('#sel-id')
    //通过setdata修改组件中的数据：不推荐这样直接修改，推荐调用组件中的方法进行修改
    my_sel.setData({
      counter:my_sel.data.counter+20
    })
    //调用组件中的方法修改数据,incrementCounter为组件中定义的方法
    my_sel.incrementCounter(10)
    
  }
})
```

组件中定义方法：

```js
//my-sel
Component({
  methods:{
    incrementCounter(num){//num为页面调用传递的参数
      this.setData({
        counter:this.data.counter+num
      })
    }
  }
})
```

### 6.8插槽slot的使用

在组件中定义结构：

```html
<!--nav-bar.wxml-->
<view class="left"><slot name="left"/></view>
<view class="center"><slot name="center"/></view>
<view class="right"><slot name="right"/></view>
```

还需要的组件中配置多插槽属性：

```js
//nav-bar.js
Component({
  options:{
    multipleSlots:true
  }
})
```

在页面中进行使用：

在页面的json文件中进行注册，页面中进行使用。

```html
<nav-bar>
  <view slot="left">左侧</view>
  <view slot="center">中间</view>
  <view slot="right">右侧</view>
</nav-bar>
```

## 7.网络请求

封装网络请求：

在项目根目录下新建`service`文件夹，在此文件夹下新建`network.js`文件用于封装网络请求。

```js
export default function request(options){
  return Promise((resolve,reject)=>{
    wx.request({
      url:options.url,
      method:options.method || 'get',
      data:options.data || {},
      success:function(res){
        resolve(res)
      },
      fail:function(err){
        reject(err)
      }
    })
  })
}
```

其他页面导入使用：

```js
//home.js
//只能使用相对路径进行导入
import request from '../../service/network.js'

//发送网络请求
request({
  url:''
}).then(res=>{
  console.log(res)
}).catch(err=>{
  console.log(err)
})
```

## 8.小程序其他技术

### 8.1弹窗

四种弹窗：

- Toast弹窗

```js
Page({
  handleShowToast({
    wx.showToast({
    title:'标题'
  })
  })
})
```



### 8.2分享

右上角菜单分享：

```js
//home.js
Page({
  onShareAppMessage:function(options){
    return {
      title:'转发标题',
      path:'转发页面路径',//默认是当前页面
      imageUrl:'图片地址：本地图片/网络图片'
    }
  }
})
```

点击按钮实现分享：

```html
<!--home.wxml-->
<button size="mini" open-type="share">
  分享
</button>
```

### 8.3登录流程

在`app.js`文件中进行编写登录操作：

```js
//app.js
const TOKEN = 'token'

App({
  // 对象: 小程序关闭掉
  globalData: {
    token: ''
  },
  onLaunch: function () {
    // 1.先从缓冲中取出token
    const token = wx.getStorageSync(TOKEN)

    // 2.判断token是否有值
    if (token && token.length !== 0) { // 已经有token,验证token是否过期
      this.check_token(token) // 验证token是否过期
    } else { // 没有token, 进行登录操作
      this.login()
    }
  },
  check_token(token) {
    console.log('执行了验证token操作')
    wx.request({
      url: 'http://123.207.32.32:3000/auth',
      method: 'post',
      header: {
        token
      },
      success: (res) => {
        if (!res.data.errCode) {
          console.log('token有效')
          this.globalData.token = token;
        } else {
          this.login()
        }
      },
      fail: function(err) {
        console.log(err)
      }
    })
  },
  login() {
    console.log('执行了登录操作')
    wx.login({
      // code只有5分钟的有效期
      success: (res) => {
        // 1.获取code
        const code = res.code;

        // 2.将code发送给我们的服务器
        wx.request({
          url: 'http://123.207.32.32:3000/login',
          method: 'post',
          data: {
            code
          },
          success: (res) => {
            // 1.取出token
            const token = res.data.token;

            // 2.将token保存在globalData中
            this.globalData.token = token;

            // 3.进行本地存储
            wx.setStorageSync(TOKEN, token)
          }
        })
      }
    })
  }
})
```

### 8.4页面跳转

navigator组件进行页面跳转操作。